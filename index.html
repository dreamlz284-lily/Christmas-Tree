<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gift from Mengjie</title>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Parisienne&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; position: absolute; }
        .fancy-font { font-family: 'Pinyon Script', cursive; }
    </style>
</head>
<body>
    <div id="container" class="relative w-full h-screen cursor-pointer">
        <canvas id="c"></canvas>
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-between py-16 pointer-events-none">
            <h1 id="h1" class="fancy-font text-5xl md:text-8xl bg-clip-text text-transparent bg-gradient-to-b from-yellow-100 via-yellow-400 to-yellow-700 animate-pulse">Gift from Mengjie</h1>
            <div id="treeText" class="opacity-0 scale-95 transition-all duration-1000 text-center">
                <h2 class="fancy-font text-6xl md:text-8xl text-yellow-400 mb-2">Merry Christmas</h2>
                <p id="msg" class="text-white/80 text-xl italic h-8 transition-opacity duration-500"></p>
                <p class="fancy-font text-2xl text-yellow-600 mt-4">From Mengjie</p>
            </div>
            <p id="hint" class="text-white/20 tracking-[0.5em] text-xs">CLICK TO UNWRAP</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
        const msgs = ["Wishing you peace & joy", "Success in 2025", "Merry Christmas!", "Stay healthy and happy"];
        let w, h, pts = [], snow = [], active = false, t = 0, rot = 0, mIdx = 0;

        function init() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            pts = [];
            const size = Math.min(w, h);
            const bS = size * 0.28, tH = h * 0.7, tB = size * 0.5;

            for(let i=0; i<8000; i++) { // 恢复到8000个粒子，兼顾细节与性能
                // 礼盒逻辑 (加上黄色细节逻辑)
                let x, y, z, s = Math.floor(Math.random()*6), u = Math.random()-0.5, v = Math.random()-0.5;
                if(s==0){x=0.5;y=u;z=v} else if(s==1){x=-0.5;y=u;z=v} else if(s==2){x=u;y=0.5;z=v}
                else if(s==3){x=u;y=-0.5;z=v} else if(s==4){x=u;y=v;z=0.5} else {x=u;y=v;z=-0.5}
                
                // 判断是否为黄色丝带区域 (坐标接近中心轴的粒子)
                const isRibbon = Math.abs(u) < 0.15 || Math.abs(v) < 0.15;
                
                // 树坐标
                const ty = Math.random() - 0.5;
                const r = Math.sqrt(Math.random()) * 0.5 * (ty + 0.5);
                const a = Math.random() * Math.PI * 2;
                
                pts.push({
                    bx: x*bS, by: y*bS, bz: z*bS,
                    tx: r*Math.cos(a)*tB, ty: ty*tH, tz: r*Math.sin(a)*tB,
                    cGift: isRibbon ? [255, 215, 0] : [200, 30, 30], // 这里的黄光找回来了！
                    cTree: [30, 100 + Math.random()*120, 50],
                    sz: Math.random()*2 + 0.8,
                    phase: Math.random() * Math.PI * 2
                });
            }
            snow = Array.from({length:100}, () => ({x:Math.random()*w, y:Math.random()*h, v:Math.random()*1.2+0.5, s:Math.random()*2}));
        }

        function draw() {
            // 1. 物理清空，确保无残影
            canvas.width = window.innerWidth; 
            
            // 2. 绘制黑色背景底色
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // 3. 开启“发光”模式
            ctx.globalCompositeOperation = 'lighter';
            
            rot += 0.008;
            if (active && t < 1) t += 0.015;
            const ease = t*t*(3-2*t), cos = Math.cos(rot), sin = Math.sin(rot);

            pts.forEach(p => {
                const px = p.bx + (p.tx - p.bx) * ease;
                const py = p.by + (p.ty - p.by) * ease;
                const pz = p.bz + (p.tz - p.bz) * ease;

                const rx = px * cos - pz * sin;
                const rz = px * sin + pz * cos;
                const s = 1000 / (1000 + rz);
                
                // 颜色平滑插值
                const r = Math.floor(p.cGift[0] + (p.cTree[0] - p.cGift[0]) * ease);
                const g = Math.floor(p.cGift[1] + (p.cTree[1] - p.cGift[1]) * ease);
                const b = Math.floor(p.cGift[2] + (p.cTree[2] - p.cGift[2]) * ease);

                // 呼吸光晕效果
                const bloom = active ? (Math.sin(Date.now()*0.005 + p.phase)*0.3 + 0.7) : 1;
                ctx.fillStyle = `rgb(${r*bloom},${g*bloom},${b*bloom})`;
                ctx.fillRect(rx*s + w/2, py*s + h/2, p.sz*s, p.sz*s);
            });

            if (active) {
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                snow.forEach(s => {
                    s.y = (s.y + s.v) % h;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.s, 0, Math.PI*2);
                    ctx.fill();
                });
            }
            requestAnimationFrame(draw);
        }

        document.getElementById('container').onclick = () => {
            if(!active) {
                active = true;
                document.getElementById('h1').style.opacity = '0';
                document.getElementById('hint').style.display = 'none';
                setTimeout(() => {
                    const t = document.getElementById('treeText');
                    t.classList.replace('opacity-0', 'opacity-100');
                    t.classList.replace('scale-95', 'scale-100');
                    updateMsg();
                }, 800);
            }
        };

        function updateMsg() {
            const el = document.getElementById('msg');
            el.style.opacity = 0;
            setTimeout(() => {
                el.innerText = msgs[mIdx];
                el.style.opacity = 1;
                mIdx = (mIdx + 1) % msgs.length;
            }, 500);
            setTimeout(updateMsg, 4000);
        }

        window.onresize = init;
        init(); draw();
    </script>
</body>
</html>
