<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gift from Mengjie</title>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Parisienne&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; position: absolute; }
        .fancy-font { font-family: 'Pinyon Script', cursive; }
    </style>
</head>
<body>
    <div id="container" class="relative w-full h-screen cursor-pointer">
        <canvas id="c"></canvas>
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-between py-16 pointer-events-none">
            <h1 id="h1" class="fancy-font text-5xl md:text-8xl bg-clip-text text-transparent bg-gradient-to-b from-yellow-100 via-yellow-400 to-yellow-700 animate-pulse">Gift from Mengjie</h1>
            <div id="treeText" class="opacity-0 scale-95 transition-all duration-1000 text-center">
                <h2 class="fancy-font text-6xl md:text-8xl text-yellow-400 mb-2">Merry Christmas</h2>
                <p id="msg" class="text-white/80 text-xl italic h-8 transition-opacity duration-500"></p>
                <p class="fancy-font text-2xl text-yellow-600 mt-4">From Mengjie</p>
            </div>
            <p id="hint" class="text-white/20 tracking-[0.5em] text-xs">CLICK TO UNWRAP</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
        const msgs = ["Wishing you peace & joy", "Success in 2025", "Merry Christmas!", "Stay healthy and happy"];
        const DECO_COLORS = [[255, 50, 50], [50, 100, 255], [220, 220, 220], [180, 50, 255], [0, 128, 128], [255, 140, 0]];

        let w, h, pts = [], snow = [], active = false, t = 0, rot = 0, mIdx = 0;

        function init() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            pts = [];
            const size = Math.min(w, h);
            const bS = size * 0.28, tH = h * 0.7, tB = size * 0.45;

            for(let i=0; i<20000; i++) {
                let bx, by, bz, s = Math.floor(Math.random()*6), u = Math.random()-0.5, v = Math.random()-0.5;
                if(s==0){bx=0.5;by=u;bz=v} else if(s==1){bx=-0.5;by=u;bz=v} else if(s==2){bx=u;by=0.5;bz=v}
                else if(s==3){bx=u;by=-0.5;bz=v} else if(s==4){bx=u;by=v;bz=0.5} else {bx=u;by=v;bz=-0.5}
                const isRibbon = Math.abs(u) < 0.12 || Math.abs(v) < 0.12;

                const ty = Math.random() - 0.5;
                const rBase = 0.5 * (ty + 0.5);
                const a = Math.random() * Math.PI * 2;
                
                let targetX, targetY, targetZ, targetColor, pSize;
                const roll = Math.random();

                if (i < 3000) { 
                    // --- 螺旋优化：增加随机偏移（空间感）和粒子粗细 ---
                    const spiralAngle = (ty + 0.5) * Math.PI * 10; 
                    const drift = (Math.random() - 0.5) * 0.2; // 增加螺旋散布感
                    targetX = Math.cos(spiralAngle + drift) * (rBase + drift) * tB;
                    targetY = ty * tH;
                    targetZ = Math.sin(spiralAngle + drift) * (rBase + drift) * tB;
                    targetColor = [210, 165, 32]; // 柔和的金麒麟色，降低刺眼度
                    pSize = Math.random() * 2.5 + 1; // 加粗螺旋粒子
                } else if (roll < 0.10) { 
                    targetX = Math.cos(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetY = ty * tH;
                    targetZ = Math.sin(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetColor = DECO_COLORS[Math.floor(Math.random() * DECO_COLORS.length)];
                    pSize = Math.random() * 2 + 1.0;
                } else { 
                    targetX = Math.cos(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetY = ty * tH;
                    targetZ = Math.sin(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetColor = [30, 100 + Math.random()*70, 50];
                    pSize = Math.random() * 1.5 + 0.8;
                }
                
                pts.push({
                    bx: bx*bS, by: by*bS, bz: bz*bS,
                    tx: targetX, ty: targetY, tz: targetZ,
                    cGift: isRibbon ? [218, 165, 32] : [180, 20, 20],
                    cTree: targetColor,
                    sz: pSize,
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.002 + Math.random() * 0.004 // 独立的呼吸速度
                });
            }
            snow = Array.from({length:80}, () => ({x:Math.random()*w, y:Math.random()*h, v:Math.random()*1.2+0.5, s:Math.random()*2}));
        }

        function draw() {
            canvas.width = window.innerWidth; 
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'lighter';
            
            rot += 0.006; // 稍微减慢旋转，增加空间沉浸感
            if (active && t < 1) t += 0.012;
            const ease = t*t*(3-2*t), cos = Math.cos(rot), sin = Math.sin(rot);

            pts.forEach(p => {
                const px = p.bx + (p.tx - p.bx) * ease;
                const py = p.by + (p.ty - p.by) * ease;
                const pz = p.bz + (p.tz - p.bz) * ease;

                const rx = px * cos - pz * sin;
                const rz = px * sin + pz * cos;
                const s = 1000 / (1000 + rz);
                
                const r = Math.floor(p.cGift[0] + (p.cTree[0] - p.cGift[0]) * ease);
                const g = Math.floor(p.cGift[1] + (p.cTree[1] - p.cGift[1]) * ease);
                const b = Math.floor(p.cGift[2] + (p.cTree[2] - p.cGift[2]) * ease);

                // --- 呼吸感优化：更深、更缓慢的波动 ---
                const shimmer = (Math.sin(Date.now() * p.speed + p.phase) * 0.3 + 0.7);
                
                // 空间感：远处的粒子稍微暗一点点
                const depthFade = Math.max(0.15, s); 
                
                ctx.fillStyle = `rgb(${r * shimmer * depthFade},${g * shimmer * depthFade},${b * shimmer * depthFade})`;
                ctx.fillRect(rx*s + w/2, py*s + h/2, p.sz*s, p.sz*s);
            });

            if (active) {
                ctx.fillStyle = "rgba(255,255,255,0.6)";
                snow.forEach(s => {
                    s.y = (s.y + s.v) % h;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.s, 0, Math.PI*2);
                    ctx.fill();
                });
            }
            requestAnimationFrame(draw);
        }

        document.getElementById('container').onclick = () => {
            if(!active) {
                active = true;
                document.getElementById('h1').style.opacity = '0';
                document.getElementById('hint').style.display = 'none';
                setTimeout(() => {
                    const t = document.getElementById('treeText');
                    t.classList.replace('opacity-0', 'opacity-100');
                    t.classList.replace('scale-95', 'scale-100');
                    updateMsg();
                }, 800);
            }
        };

        function updateMsg() {
            const el = document.getElementById('msg');
            el.style.opacity = 0;
            setTimeout(() => {
                el.innerText = msgs[mIdx];
                el.style.opacity = 1;
                mIdx = (mIdx + 1) % msgs.length;
            }, 500);
            setTimeout(updateMsg, 4000);
        }

        window.onresize = init;
        init(); draw();
    </script>
</body>
</html>
