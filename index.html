<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gift from Mengjie</title>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Parisienne&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; width: 100vw; height: 100vh; }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        .fancy-font { font-family: 'Pinyon Script', cursive; }
        /* 纯净磨砂层 */
        .glass-blur {
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            background: rgba(255, 255, 255, 0.02);
        }
    </style>
</head>
<body>
    <div id="container" class="relative w-full h-screen cursor-pointer bg-black">
        <canvas id="c"></canvas>
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-between py-16 pointer-events-none">
            <h1 id="h1" class="fancy-font text-5xl md:text-7xl bg-clip-text text-transparent bg-gradient-to-b from-yellow-100 via-yellow-400 to-yellow-700 transition-opacity duration-1000">Gift from Mengjie</h1>
            
            <div id="treeText" class="opacity-0 scale-95 transition-all duration-1000 text-center glass-blur px-16 py-10 rounded-full">
                <h2 class="fancy-font text-5xl md:text-6xl text-yellow-400 mb-2">Merry Christmas</h2>
                <p id="msg" class="text-white/90 text-2xl md:text-3xl italic h-16 transition-opacity duration-1000 flex items-center justify-center px-4"></p>
                <p class="fancy-font text-3xl text-yellow-600 mt-4">From Mengjie</p>
            </div>
            
            <p id="hint" class="text-white/20 tracking-[0.5em] text-xs">CLICK TO UNWRAP</p>
        </div>
    </div>

    <script>
        // 1. 基础配置
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const msgs = ["Wishing you peace and happiness", "Success and joy in 2026", "Thank you for your support!", "Merry Christmas!"];
        const DECO_COLORS = [[255, 69, 0], [255, 165, 0], [255, 215, 0], [255, 105, 180], [255, 50, 50]];

        let w, h, pts = [], snow = [], active = false, t = 0, rot = 0, mIdx = 0;

        // 2. 初始化函数
        function init() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            pts = [];
            
            const size = Math.min(w, h);
            const bS = size * 0.28; 
            const tH = h * 0.7; 
            const tB = size * 0.45;

            // 生成20000个粒子
            for(let i = 0; i < 20000; i++) {
                // 盒子坐标
                let bx, by, bz, s = Math.floor(Math.random()*6), u = Math.random()-0.5, v = Math.random()-0.5;
                if(s==0){bx=0.5;by=u;bz=v} else if(s==1){bx=-0.5;by=u;bz=v} else if(s==2){bx=u;by=0.5;bz=v}
                else if(s==3){bx=u;by=-0.5;bz=v} else if(s==4){bx=u;by=v;bz=0.5} else {bx=u;by=v;bz=-0.5}
                
                const isRibbon = Math.abs(u) < 0.12 || Math.abs(v) < 0.12;
                const ty = Math.random() - 0.5;
                const rBase = 0.5 * (ty + 0.5);
                const a = Math.random() * Math.PI * 2;
                
                let tx, ty_p, tz, col, sz, isStar = false;
                const roll = Math.random();

                if (i < 600) { 
                    // 树顶星
                    isStar = true;
                    const sA = Math.random() * Math.PI * 2;
                    const sD = Math.random() * 30; 
                    tx = Math.cos(sA) * sD;
                    ty_p = -tH/2 - 30; 
                    tz = Math.sin(sA) * sD;
                    col = [255, 255, 200]; 
                    sz = Math.random() * 3 + 1.5; 
                } else if (i < 5000) { 
                    // 金色螺旋
                    const sAng = (ty + 0.5) * Math.PI * 10; 
                    const dr = (Math.random() - 0.5) * 0.2; 
                    tx = Math.cos(sAng + dr) * (rBase + dr) * tB;
                    ty_p = ty * tH;
                    tz = Math.sin(sAng + dr) * (rBase + dr) * tB;
                    col = [255, 215, 30]; 
                    sz = Math.random() * 2.5 + 1.0; 
                } else if (roll < 0.2) { 
                    // 装饰球
                    tx = Math.cos(a) * rBase * Math.sqrt(Math.random()) * tB;
                    ty_p = ty * tH;
                    tz = Math.sin(a) * rBase * Math.sqrt(Math.random()) * tB;
                    col = DECO_COLORS[Math.floor(Math.random() * DECO_COLORS.length)];
                    sz = Math.random() * 2.2 + 1.2;
                } else { 
                    // 绿叶
                    tx = Math.cos(a) * rBase * Math.sqrt(Math.random()) * tB;
                    ty_p = ty * tH;
                    tz = Math.sin(a) * rBase * Math.sqrt(Math.random()) * tB;
                    col = [60, 180 + Math.random()*75, 50]; 
                    sz = Math.random() * 1.5 + 0.5;
                }
                
                pts.push({
                    bx: bx*bS, by: by*bS, bz: bz*bS,
                    tx: tx, ty: ty_p, tz: tz,
                    c1: isRibbon ? [255, 215, 0] : [200, 30, 30], // 礼盒颜色
                    c2: col, // 树颜色
                    sz: sz,
                    isS: isStar,
                    ph: Math.random() * Math.PI * 2,
                    sp: 0.002 + Math.random() * 0.004
                });
            }
            
            // 300颗密集雪花
            snow = Array.from({length: 300}, () => ({
                x: Math.random() * w, y: Math.random() * h, 
                v: Math.random() * 1.5 + 0.5, s: Math.random() * 2.5 + 0.5,
                w: (Math.random() - 0.5) * 0.5
            }));
        }

        // 3. 渲染循环
        function draw() {
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'lighter';
            
            rot += 0.006; 
            if (active && t < 1) t += 0.012;
            const ease = t*t*(3-2*t), cos = Math.cos(rot), sin = Math.sin(rot);

            for (let i = 0; i < pts.length; i++) {
                const p = pts[i];
                const px = p.bx + (p.tx - p.bx) * ease;
                const py = p.by + (p.ty - p.by) * ease;
                const pz = p.bz + (p.tz - p.bz) * ease;
                
                const rx = px * cos - pz * sin;
                const rz = px * sin + pz * cos;
                const s = 1000 / (1000 + rz);
                
                const r = Math.floor(p.c1[0] + (p.c2[0] - p.c1[0]) * ease);
                const g = Math.floor(p.c1[1] + (p.c2[1] - p.c1[1]) * ease);
                const b = Math.floor(p.c1[2] + (p.c2[2] - p.c1[2]) * ease);

                let sh = (Math.sin(Date.now() * p.sp + p.ph) * 0.2 + 0.8);
                if(p.isS && active) sh += Math.random() * 0.4;

                const df = Math.max(0.15, s); 
                ctx.fillStyle = `rgb(${Math.floor(r * sh * df)},${Math.floor(g * sh * df)},${Math.floor(b * sh * df)})`;
                ctx.fillRect(rx*s + w/2, py*s + h/2, p.sz*s, p.sz*s);
            }

            if (active) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                for (let i = 0; i < snow.length; i++) {
                    const sn = snow[i];
                    sn.y = (sn.y + sn.v) % h;
                    sn.x = (sn.x + sn.w + w) % w;
                    ctx.beginPath();
                    ctx.arc(sn.x, sn.y, sn.s, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            requestAnimationFrame(draw);
        }

        // 4. 事件交互
        document.getElementById('container').onclick = () => {
            if(!active) {
                active = true;
                document.getElementById('h1').style.opacity = '0';
                document.getElementById('hint').style.display = 'none';
                setTimeout(() => {
                    const el = document.getElementById('treeText');
                    el.classList.replace('opacity-0', 'opacity-100');
                    el.classList.replace('scale-95', 'scale-100');
                    updateMsg();
                }, 800);
            }
        };

        function updateMsg() {
            const el = document.getElementById('msg');
            el.style.opacity = 0;
            setTimeout(() => {
                el.innerText = msgs[mIdx];
                el.style.opacity = 1;
                mIdx = (mIdx + 1) % msgs.length;
            }, 1000);
            setTimeout(updateMsg, 5000);
        }

        window.onresize = init;
        init(); 
        draw();
    </script>
</body>
</html>
