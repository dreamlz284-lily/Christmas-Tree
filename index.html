<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gift from Mengjie</title>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Parisienne&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; position: absolute; }
        .fancy-font { font-family: 'Pinyon Script', cursive; }
        .pure-blur {
            position: relative;
            z-index: 10; /* Ensures the box is on top of particles */
            
            /* High-strength blur */
            backdrop-filter: blur(8px) saturate(120%);
            -webkit-backdrop-filter: blur(8px) saturate(120%);
            
            /* A slightly stronger semi-transparent black helps the blur show up */
            background: rgba(0, 0, 0, 0.1); 
            
            border: none;
            /* Shadow creates a soft 'glow' edge instead of a hard line */
            box-shadow: 0 0 20px 10px rgba(0, 0, 0, 0.1); 
        }
    </style>
</head>
<body>
    <div id="container" class="relative w-full h-screen cursor-pointer">
        <canvas id="c"></canvas>
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-between py-16 pointer-events-none">
            <h1 id="h1" class="fancy-font text-4xl md:text-7xl bg-clip-text text-transparent bg-gradient-to-b from-yellow-100 via-yellow-400 to-yellow-700 transition-opacity duration-1000">Gift from Mengjie</h1>
            <div id="treeText" class="opacity-0 scale-95 transition-all duration-1000 text-center pure-blur px-3 py-2 rounded-[20px]">
                <h2 class="fancy-font text-5xl md:text-6xl text-yellow-400 mb-2">Merry Christmas</h2>
                <p id="msg" class="text-white/80 text-3xl italic h-16 transition-opacity duration-1000"></p>
                <p class="fancy-font text-3xl text-yellow-600 mt-4">From Mengjie</p>
            </div>
            <p id="hint" class="text-white/20 tracking-[0.5em] text-xs">CLICK TO UNWRAP</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
        const msgs = ["Best wishes for a happy holiday season", "Success in 2026", "Thank you for your support!", "Wishing you peace and happiness"];
        
        // 暖色系：金、橙、红、琥珀
        const DECO_COLORS = [[255, 69, 5], [255, 165, 0], [255, 215, 0], [255, 105, 180], [255, 50, 50]];

        let w, h, pts = [], snow = [], active = false, t = 0, rot = 0, mIdx = 0;

        function init() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            pts = [];
            const size = Math.min(w, h);
            const bS = size * 0.28, tH = h * 0.7, tB = size * 0.6;

            // 恢复 20,000 个粒子
            for(let i=0; i<20000; i++) {
                let bx, by, bz, s = Math.floor(Math.random()*6), u = Math.random()-0.5, v = Math.random()-0.5;
                if(s==0){bx=0.5;by=u;bz=v} else if(s==1){bx=-0.5;by=u;bz=v} else if(s==2){bx=u;by=0.5;bz=v}
                else if(s==3){bx=u;by=-0.5;bz=v} else if(s==4){bx=u;by=v;bz=0.5} else {bx=u;by=v;bz=-0.5}
                const isRibbon = Math.abs(u) < 0.12 || Math.abs(v) < 0.12;

                const ty = Math.random() - 0.5;
                const rBase = 0.5 * (ty + 0.5);
                const a = Math.random() * Math.PI * 2;
                
                let targetX, targetY, targetZ, targetColor, pSize, isSpiral = false, isStar = false;
                const roll = Math.random();

                if (i < 750) { 
                    // --- 五角星形状算法 ---
                    isStar = true;
                    // 五角星的数学参数
                    const numPoints = 5;
                    const innerRadius = 25;  // 内径
                    const outerRadius = 850; // 外径
                    
                    // 随机选择一个点在星形线上或内部
                    const angle = Math.random() * Math.PI * 2;
                    const modAngle = angle % (Math.PI * 2 / numPoints);
                    const halfAngle = Math.PI / numPoints;
                    
                    // 计算当前角度对应的星形半径
                    let rStar;
                    if (modAngle < halfAngle) {
                        rStar = innerRadius * outerRadius / (outerRadius * Math.cos(modAngle) + innerRadius * Math.sin(halfAngle - modAngle));
                    } else {
                        rStar = innerRadius * outerRadius / (outerRadius * Math.cos(2 * halfAngle - modAngle) + innerRadius * Math.sin(modAngle - halfAngle));
                    }
                    
                    const dist = Math.pow(Math.random(), 0.7) * rStar; // 让粒子填满星形内部
                    
                    tx = Math.cos(angle - Math.PI/2) * dist; // 旋转 -90度让尖角朝上
                    typ = -tH/2 - 45 + (Math.sin(angle - Math.PI/2) * dist); 
                    tz = (Math.random() - 0.5) * 10; // 让星星有一点点厚度
                    
                    col = [250, 142, 10]; 
                    sz = Math.random() * 0.5 + 1;
                } else if (i < 5000) { // 金色螺旋：快速旋转
                    isSpiral = true;
                    const sAng = (ty + 0.5) * Math.PI * 10; 
                    const dr = (Math.random() - 0.5) * 0.1; 
                    tx = Math.cos(sAng + dr) * (rBase + dr) * tB;
                    typ = ty * tH;
                    tz = Math.sin(sAng + dr) * (rBase + dr) * tB;
                    col = [255, 210, 30]; sz = Math.random() * 2.5 + 1.0;
            } else { // 树体：慢速旋转
                    tx = Math.cos(a) * rBase * Math.sqrt(Math.random()) * tB;
                    typ = ty * tH;
                    tz = Math.sin(a) * rBase * Math.sqrt(Math.random()) * tB;
                    col = (Math.random() < 0.15) ? DECO_COLORS[i%5] : [60, 180 + Math.random()*75, 50];
                    sz = Math.random() * 1.8 + 1.0;
            }
                
                pts.push({
                    bx: bx*bS, by: by*bS, bz: bz*bS,
                    tx, ty: typ, tz,
                    c1: isRibbon ? [255, 215, 0] : [200, 30, 30],
                    c2: col, sz, isSpiral, isStar,
                    ph: Math.random() * Math.PI * 2,
                    sp: 0.002 + Math.random() * 0.004
                });
            }
            snow = Array.from({length: 310}, () => ({
                x: Math.random() * w, y: Math.random() * h, 
                v: Math.random() * 1.5 + 0.5, s: Math.random() * 1.5 + 0.5,
                w: (Math.random() - 0.5) * 0.5
            }));
        }

        function draw() {
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'lighter';
            
            // --- 核心修改：定义两个速度 ---
            rot += 0.004; // 树体旋转速度（慢）
            let spiralRot = rot * 2; // 金色光芒旋转速度（快，2倍速）

            if (active && t < 1) t += 0.012;
            const ease = t*t*(3-2*t);
            
            // 预计算两种角度
            const cosT = Math.cos(rot), sinT = Math.sin(rot);
            const cosS = Math.cos(spiralRot), sinS = Math.sin(spiralRot);

            for (let i = 0; i < pts.length; i++) {
                const p = pts[i];
                const px = p.bx + (p.tx - p.bx) * ease;
                const py = p.by + (p.ty - p.by) * ease;
                const pz = p.bz + (p.tz - p.bz) * ease;
                
                // 根据类型选择旋转角度
                const cos = p.isSpiral ? cosS : cosT;
                const sin = p.isSpiral ? sinS : sinT;

                const rx = px * cos - pz * sin;
                const rz = px * sin + pz * cos;
                const s = 1000 / (1000 + rz);
                
                const r = Math.floor(p.c1[0] + (p.c2[0] - p.c1[0]) * ease);
                const g = Math.floor(p.c1[1] + (p.c2[1] - p.c1[1]) * ease);
                const b = Math.floor(p.c1[2] + (p.c2[2] - p.c1[2]) * ease);

                let sh = (Math.sin(Date.now() * p.sp + p.ph) * 0.15 + 0.85);
                if(p.isStar && active) sh += Math.random() * 0.4;

                ctx.fillStyle = `rgb(${Math.floor(r * sh * s)},${Math.floor(g * sh * s)},${Math.floor(b * sh * s)})`;
                ctx.fillRect(rx*s + w/2, py*s + h/2, p.sz*s, p.sz*s);
            }

            if (active) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                for (let i = 0; i < snow.length; i++) {
                    const sn = snow[i];
                    sn.y = (sn.y + sn.v) % h; sn.x = (sn.x + sn.w + w) % w;
                    ctx.beginPath(); ctx.arc(sn.x, sn.y, sn.s, 0, 7); ctx.fill();
                }
            }
            requestAnimationFrame(draw);
        }

        document.getElementById('container').onclick = () => {
            if(!active) {
                active = true;
                // --- ADJUST VOLUME HERE ---
                // 1.0 is max, 0.0 is silent. 0.3 is 30% volume.
                audio.volume = 0.8; 
                
                audio.play().catch(e => console.log("Audio block:", e));
                document.getElementById('h1').style.opacity = '0';
                document.getElementById('hint').style.display = 'none';
                setTimeout(() => {
                    const t = document.getElementById('treeText');
                    t.classList.replace('opacity-0', 'opacity-100');
                    t.classList.replace('scale-95', 'scale-100');
                    updateMsg();
                }, 800);
            }
        };

        function updateMsg() {
            const el = document.getElementById('msg');
            el.style.opacity = 0;
            setTimeout(() => {
                el.innerText = msgs[mIdx];
                el.style.opacity = 1;
                mIdx = (mIdx + 1) % msgs.length;
            }, 1000);
            setTimeout(updateMsg, 5000);
        }

        window.onresize = init;
        init(); draw();
    </script>
</body>
</html>
