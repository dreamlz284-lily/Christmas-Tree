<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gift from Mengjie</title>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Parisienne&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .fancy-font { font-family: 'Pinyon Script', cursive; }
        .greeting-font { font-family: 'Parisienne', cursive; }
    </style>
</head>
<body class="bg-black">
    <div id="container" class="relative w-full h-screen overflow-hidden cursor-pointer">
        <canvas id="treeCanvas"></canvas>
        <div class="absolute inset-0 pointer-events-none bg-[radial-gradient(circle_at_center,_transparent_0%,_rgba(0,0,0,0.6)_100%)]"></div>

        <div id="giftUI" class="absolute inset-0 flex flex-col transition-opacity duration-1000">
            <div class="h-1/3 flex items-center justify-center pt-8">
                <h2 class="fancy-font text-4xl md:text-7xl bg-clip-text text-transparent bg-gradient-to-b from-yellow-50 via-yellow-400 to-yellow-800 animate-pulse text-center px-4">
                    Gift from Mengjie
                </h2>
            </div>
            <div class="flex-1"></div>
            <div class="h-1/3 flex items-start justify-center pt-12">
                <p class="text-white/40 uppercase tracking-[0.4em] text-xs md:text-sm animate-bounce">Click to Open</p>
            </div>
        </div>

        <div id="treeUI" class="absolute bottom-0 w-full h-[35%] flex flex-col items-center justify-end pb-12 pointer-events-none transition-opacity duration-1000 opacity-0">
            <div class="absolute inset-0 bg-gradient-to-t from-black via-black/40 to-transparent"></div>
            <div class="relative z-10 text-center w-full px-4 max-w-4xl mx-auto">
                <h1 class="fancy-font text-4xl md:text-6xl mb-2 bg-clip-text text-transparent bg-gradient-to-b from-yellow-100 via-yellow-400 to-yellow-800">
                    Merry Christmas
                </h1>
                <div id="greetingWrapper" class="transition-opacity duration-500 h-16 md:h-24 flex items-center justify-center">
                    <p id="greetingText" class="greeting-font text-lg md:text-3xl text-white text-center"></p>
                </div>
                <p class="fancy-font text-lg md:text-2xl mt-2 text-yellow-500">From Mengjie</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        const GREETINGS = [
            "Wishing you a joyful Christmas and a New Year filled with good health and success.",
            "Warmest wishes to you and your family for a peaceful and wonderful Christmas season.",
            "May this Christmas bring you moments of rest, joy, and time well spent with loved ones.",
            "Best wishes for a happy holiday season and a prosperous New Year ahead."
        ];

        let particles = [], snowParticles = [], isGiftPhase = true, isTransitioning = false, gIndex = 0;
        let rot = { x: 0, y: 0 }, zoom = 1.0, transitionStart = 0;

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const w = canvas.width, h = canvas.height;
            const treeH = h * 0.75, baseW = w * (w < 768 ? 0.85 : 0.45), boxS = Math.min(w, h) * 0.22;
            
            particles = [];
            snowParticles = [];

            // 1. 生成树粒子 (包含礼盒形态)
            for (let i = 0; i < 15000; i++) {
                const y = (Math.random() - 0.5) * treeH;
                const prog = (y + treeH / 2) / treeH;
                const r = Math.sqrt(Math.random()) * (baseW / 2) * prog;
                const ang = Math.random() * Math.PI * 2;
                
                let bx, by, bz, side = Math.floor(Math.random() * 6);
                let u = (Math.random()-0.5)*boxS, v = (Math.random()-0.5)*boxS, d = boxS/2;
                if(side==0){bx=d;by=u;bz=v} else if(side==1){bx=-d;by=u;bz=v} else if(side==2){bx=u;by=d;bz=v}
                else if(side==3){bx=u;by=-d;bz=v} else if(side==4){bx=u;by=v;bz=d} else {bx=u;by=v;bz=-d}

                particles.push({
                    sx: bx, sy: by, sz: bz, // 礼盒坐标
                    ix: r * Math.cos(ang), iy: y, iz: r * Math.sin(ang), // 树坐标
                    color: (Math.abs(bx)<boxS*0.15||Math.abs(by)<boxS*0.15||Math.abs(bz)<boxS*0.15) ? [255,215,0] : [180,20,20],
                    treeColor: [20, Math.floor(Math.random()*140+80), 40],
                    size: Math.random() * 1.2 + 0.3,
                    life: Math.random() * 100
                });
            }

            // 2. 独立生成雪花粒子 (修复线性问题)
            for (let i = 0; i < 500; i++) {
                snowParticles.push({
                    x: (Math.random() - 0.5) * w * 2,
                    y: (Math.random() - 0.5) * h * 2,
                    z: (Math.random() - 0.5) * 500,
                    vx: (Math.random() - 0.5) * 1.5, // 随机横向漂移
                    vy: Math.random() * 1.5 + 0.5,   // 随机下落速度
                    size: Math.random() * 2 + 0.5
                });
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'lighter';
            
            const now = performance.now();
            let t = isTransitioning ? Math.min(1, (now - transitionStart) / 3000) : 0;
            const ease = (t) => t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;

            // 旋转驱动
            rot.y += isGiftPhase ? 0.005 : 0.003;
            const cY = Math.cos(rot.y), sY = Math.sin(rot.y);

            // A. 渲染树/礼盒粒子
            particles.forEach(p => {
                let tx, ty, tz;
                if (isTransitioning || !isGiftPhase) {
                    const e = ease(t || 1);
                    tx = p.sx + (p.ix - p.sx) * e;
                    ty = p.sy + (p.iy - p.sy) * e;
                    tz = p.sz + (p.iz - p.sz) * e;
                } else {
                    tx = p.sx; ty = p.sy; tz = p.sz;
                }

                const x1 = tx * cY - tz * sY, z1 = tx * sY + tz * cY;
                const sc = (800 / (800 + z1)) * zoom;
                const screenX = x1 * sc + canvas.width/2, screenY = ty * sc + canvas.height/2;

                if (isGiftPhase && !isTransitioning) {
                    ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},0.4)`;
                } else {
                    p.life += 0.05;
                    const shimmer = Math.sin(p.life) * 0.2 + 0.8;
                    ctx.fillStyle = `rgba(${p.treeColor[0]},${p.treeColor[1] * shimmer},${p.treeColor[2]},0.5)`;
                }
                ctx.fillRect(screenX, screenY, p.size * sc, p.size * sc);
            });

            // B. 渲染雪花 (修复随机落下逻辑)
            if (!isGiftPhase || isTransitioning) {
                const snowAlpha = isTransitioning ? t : 1;
                ctx.fillStyle = `rgba(255, 255, 255, ${snowAlpha * 0.7})`;
                snowParticles.forEach(sp => {
                    sp.x += sp.vx;
                    sp.y += sp.vy;
                    
                    // 边界重置
                    if (sp.y > canvas.height/2) sp.y = -canvas.height/2;
                    if (sp.x > canvas.width/2) sp.x = -canvas.width/2;
                    if (sp.x < -canvas.width/2) sp.x = canvas.width/2;

                    const sc = (800 / (800 + sp.z)) * zoom;
                    ctx.beginPath();
                    ctx.arc(sp.x * sc + canvas.width/2, sp.y * sc + canvas.height/2, sp.size * sc, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            requestAnimationFrame(draw);
        }

        container.addEventListener('click', () => {
            if (isGiftPhase && !isTransitioning) {
                isTransitioning = true;
                transitionStart = performance.now();
                document.getElementById('giftUI').classList.add('opacity-0');
                setTimeout(() => {
                    isGiftPhase = false;
                    document.getElementById('treeUI').classList.replace('opacity-0', 'opacity-100');
                    updateGreeting();
                }, 1000);
            }
        });

        function updateGreeting() {
            document.getElementById('greetingText').innerText = GREETINGS[gIndex];
            setInterval(() => {
                const el = document.getElementById('greetingWrapper');
                el.style.opacity = 0;
                setTimeout(() => {
                    gIndex = (gIndex + 1) % GREETINGS.length;
                    document.getElementById('greetingText').innerText = GREETINGS[gIndex];
                    el.style.opacity = 1;
                }, 500);
            }, 6000);
        }

        window.addEventListener('resize', init);
        init(); draw();
    </script>
</body>
</html>
