<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gift from Mengjie</title>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Parisienne&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; position: absolute; }
        .fancy-font { font-family: 'Pinyon Script', cursive; }
    </style>
</head>
<body>
    <div id="container" class="relative w-full h-screen cursor-pointer">
        <canvas id="c"></canvas>
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-between py-16 pointer-events-none">
            <h1 id="h1" class="fancy-font text-5xl md:text-8xl bg-clip-text text-transparent bg-gradient-to-b from-yellow-100 via-yellow-400 to-yellow-700 animate-pulse">Gift from Mengjie</h1>
            <div id="treeText" class="opacity-0 scale-95 transition-all duration-1000 text-center">
                <h2 class="fancy-font text-6xl md:text-8xl text-yellow-400 mb-2">Merry Christmas</h2>
                <p id="msg" class="text-white/80 text-xl italic h-8 transition-opacity duration-500"></p>
                <p class="fancy-font text-2xl text-yellow-600 mt-4">From Mengjie</p>
            </div>
            <p id="hint" class="text-white/20 tracking-[0.5em] text-xs">CLICK TO UNWRAP</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
        const msgs = ["Wishing you peace & joy", "Success in 2025", "Merry Christmas!", "Stay healthy and happy"];
        // 装饰球颜色库
        const DECO_COLORS = [
            [255, 50, 50],   // 红色
            [50, 100, 255],  // 蓝色
            [220, 220, 220], // 银色
            [180, 50, 255],  // 紫色
            [0, 128, 128],   // Teal色
            [255, 140, 0]    // 橙色
        ];

        let w, h, pts = [], snow = [], active = false, t = 0, rot = 0, mIdx = 0;

        function init() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            pts = [];
            const size = Math.min(w, h);
            const bS = size * 0.28, tH = h * 0.7, tB = size * 0.45;

            for(let i=0; i<10000; i++) {
                let bx, by, bz, s = Math.floor(Math.random()*6), u = Math.random()-0.5, v = Math.random()-0.5;
                if(s==0){bx=0.5;by=u;bz=v} else if(s==1){bx=-0.5;by=u;bz=v} else if(s==2){bx=u;by=0.5;bz=v}
                else if(s==3){bx=u;by=-0.5;bz=v} else if(s==4){bx=u;by=v;bz=0.5} else {bx=u;by=v;bz=-0.5}
                const isRibbon = Math.abs(u) < 0.12 || Math.abs(v) < 0.12;

                const ty = Math.random() - 0.5;
                const rBase = 0.5 * (ty + 0.5);
                const a = Math.random() * Math.PI * 2;
                
                let targetX, targetY, targetZ, targetColor;
                const roll = Math.random();

                if (i < 2000) { // 螺旋灯带粒子 (保持金黄色)
                    const spiralAngle = (ty + 0.5) * Math.PI * 12;
                    targetX = Math.cos(spiralAngle) * rBase * tB;
                    targetY = ty * tH;
                    targetZ = Math.sin(spiralAngle) * rBase * tB;
                    targetColor = [255, 230, 100];
                } else if (roll < 0.15) { // 15% 的粒子作为彩色装饰球
                    targetX = Math.cos(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetY = ty * tH;
                    targetZ = Math.sin(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetColor = DECO_COLORS[Math.floor(Math.random() * DECO_COLORS.length)];
                } else { // 剩余粒子作为绿色背景
                    targetX = Math.cos(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetY = ty * tH;
                    targetZ = Math.sin(a) * rBase * Math.sqrt(Math.random()) * tB;
                    targetColor = [30, 100 + Math.random()*80, 40];
                }
                
                pts.push({
                    bx: bx*bS, by: by*bS, bz: bz*bS,
                    tx: targetX, ty: targetY, tz: targetZ,
                    cGift: isRibbon ? [255, 215, 0] : [200, 30, 30],
                    cTree: targetColor,
                    sz: (i < 2000 || roll < 0.15) ? Math.random()*2.5 + 1.2 : Math.random()*1.5 + 0.5,
                    phase: Math.random() * Math.PI * 2
                });
            }
            snow = Array.from({length:80}, () => ({x:Math.random()*w, y:Math.random()*h, v:Math.random()*1.2+0.5, s:Math.random()*2}));
        }

        function draw() {
            canvas.width = window.innerWidth; 
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'lighter';
            
            rot += 0.008;
            if (active && t < 1) t += 0.012; // 稍微放慢一点点变换，增加优雅感
            const ease = t*t*(3-2*t), cos = Math.cos(rot), sin = Math.sin(rot);

            pts.forEach(p => {
                const px = p.bx + (p.tx - p.bx) * ease;
                const py = p.by + (p.ty - p.by) * ease;
                const pz = p.bz + (p.tz - p.bz) * ease;

                const rx = px * cos - pz * sin;
                const rz = px * sin + pz * cos;
                const s = 1000 / (1000 + rz);
                
                const r = Math.floor(p.cGift[0] + (p.cTree[0] - p.cGift[0]) * ease);
                const g = Math.floor(p.cGift[1] + (p.cTree[1] - p.cGift[1]) * ease);
                const b = Math.floor(p.cGift[2] + (p.cTree[2] - p.cGift[2]) * ease);

                // 让装饰粒子和螺旋粒子的闪烁感更强
                const shimmer = (Math.sin(Date.now()*0.005 + p.phase)*0.35 + 0.65);
                ctx.fillStyle = `rgb(${r*shimmer},${g*shimmer},${b*shimmer})`;
                ctx.fillRect(rx*s + w/2, py*s + h/2, p.sz*s, p.sz*s);
            });

            if (active) {
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                snow.forEach(s => {
                    s.y = (s.y + s.v) % h;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.s, 0, Math.PI*2);
                    ctx.fill();
                });
            }
            requestAnimationFrame(draw);
        }

        document.getElementById('container').onclick = () => {
            if(!active) {
                active = true;
                document.getElementById('h1').style.opacity = '0';
                document.getElementById('hint').style.display = 'none';
                setTimeout(() => {
                    const t = document.getElementById('treeText');
                    t.classList.replace('opacity-0', 'opacity-100');
                    t.classList.replace('scale-95', 'scale-100');
                    updateMsg();
                }, 800);
            }
        };

        function updateMsg() {
            const el = document.getElementById('msg');
            el.style.opacity = 0;
            setTimeout(() => {
                el.innerText = msgs[mIdx];
                el.style.opacity = 1;
                mIdx = (mIdx + 1) % msgs.length;
            }, 500);
            setTimeout(updateMsg, 4000);
        }

        window.onresize = init;
        init(); draw();
    </script>
</body>
</html>
